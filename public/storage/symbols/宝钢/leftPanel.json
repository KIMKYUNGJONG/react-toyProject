{
  "modified": "Wed Jul 03 2019 15:44:05 GMT+0900 (한국 표준시)",
  "background": "rgb(61,61,61)",
  "dataBindings": [
    {
      "attr": "totalDrop",
      "valueType": "String"
    },
    {
      "attr": "mainTransformer",
      "valueType": "Multiline",
      "name": "editor.content"
    },
    {
      "attr": "power",
      "valueType": "String"
    },
    {
      "attr": "powerSupply",
      "valueType": "Multiline",
      "name": "editor.content"
    },
    {
      "attr": "HVSwitchStation1",
      "valueType": "Multiline",
      "name": "editor.content"
    },
    {
      "attr": "HVSwitchStation2",
      "valueType": "Multiline",
      "name": "editor.content"
    },
    {
      "attr": "HVSwitchStation3",
      "valueType": "Multiline",
      "name": "editor.content"
    }
  ],
  "connectActionType": "copyStyle",
  "width": 239,
  "height": 700,
  "fitSize": true,
  "clip": true,
  "attachStyle": "close",
  "comps": [
    {
      "type": "shape",
      "background": "rgba(20,20,61,0.40)",
      "borderColor": "rgb(41,155,217)",
      "movable": false,
      "rotation": 3.14159,
      "onUp": "__ht__function(event, data, view, point, width, height) {\nif(window.G){\n    G.event.fire({\n        kind: 'showCabinetInfo'\n    });\n}\n}",
      "points": [
        23.45789,
        12.28489,
        208.56181,
        12.28554,
        215.22283,
        20.36124,
        215.22277,
        68.46634,
        212.54648,
        74.79661,
        212.54648,
        157.70841,
        215.22264,
        165.00194,
        215.22257,
        210.56068,
        208.56141,
        220.39191,
        150.18778,
        220.39169,
        143.89497,
        210.56037,
        23.45749,
        210.55993,
        16.64129,
        200.72829,
        16.64134,
        165.00092,
        20.1837,
        157.70841,
        20.1837,
        74.79661,
        16.64146,
        68.46533,
        16.64153,
        20.36021,
        23.45789,
        12.28489
      ]
    },
    {
      "type": "shape",
      "background": "rgb(29,110,122)",
      "fillRule": "evenodd",
      "rotation": 6.28319,
      "points": [
        108.93581,
        8.63057,
        116.30006,
        15.93869,
        95.97755,
        15.93879,
        87.93658,
        8.63057
      ]
    },
    {
      "type": "shape",
      "background": "rgb(29,110,122)",
      "fillRule": "evenodd",
      "opacity": 0.7,
      "rotation": 6.28319,
      "points": [
        135.36929,
        8.63057,
        142.73353,
        15.93869,
        121.89623,
        15.93869,
        114.37006,
        8.63057
      ]
    },
    {
      "type": "shape",
      "background": "rgb(29,110,122)",
      "fillRule": "evenodd",
      "opacity": 0.4,
      "rotation": 6.28319,
      "points": [
        161.80276,
        8.63057,
        169.167,
        15.93869,
        148.32971,
        15.93869,
        140.80354,
        8.63057
      ]
    },
    {
      "type": "shape",
      "borderWidth": 2,
      "borderColor": "rgba(41,155,217,0.51)",
      "borderCap": "round",
      "borderJoin": "bevel",
      "pixelPerfect": true,
      "scaleY": -1,
      "rotation": -1.5708,
      "points": [
        -298.07168,
        376.09387,
        -88.69255,
        376.0931,
        -80.68858,
        366.53685,
        -33.06694,
        366.53668,
        -63.68358,
        345.99825,
        139.37436,
        345.99751,
        166.47896,
        376.09216,
        382.96376,
        376.09137,
        382.96352,
        312.22898
      ],
      "segments": [
        1,
        2,
        2,
        2,
        1,
        2,
        2,
        2,
        2
      ]
    },
    {
      "type": "rect",
      "borderColor": "#979797",
      "movable": false,
      "editable": false,
      "displayName": "返回首页",
      "rect": [
        14.12264,
        8.6305,
        249.95693,
        28.58417
      ],
      "onUp": "__ht__function(event, data, view, point, width, height) {\nif(window.G){\n    G.event.fire({\n        kind: 'backHome'\n    });\n}\n}"
    },
    {
      "type": "shape",
      "background": "rgba(20,20,61,0.40)",
      "borderColor": "rgb(41,155,217)",
      "movable": false,
      "editable": false,
      "pixelPerfect": true,
      "rotation": 3.14159,
      "points": [
        37.55896,
        481.42351,
        219.12069,
        481.42412,
        228.1206,
        489.39373,
        228.12053,
        536.86624,
        224.92472,
        543.11322,
        224.92472,
        624.93472,
        228.12037,
        632.13235,
        228.12007,
        676.33104,
        213.62463,
        686.79387,
        41.97133,
        686.79345,
        28.61094,
        676.33054,
        28.61107,
        632.13126,
        32.84109,
        624.93465,
        32.84109,
        543.11315,
        28.61122,
        536.86515,
        28.61141,
        489.39323,
        37.55896,
        481.42351
      ]
    },
    {
      "type": "shape",
      "background": "rgb(16,82,92)",
      "borderColor": "rgb(97,3,3)",
      "fillRule": "evenodd",
      "pixelPerfect": true,
      "displayName": "标题",
      "rotation": -1.5708,
      "points": [
        116.87013,
        342.57363,
        116.87013,
        354.96796,
        103.01012,
        368.27532,
        -64.16702,
        368.27532,
        -76.69242,
        354.96796,
        -76.69242,
        342.57363
      ]
    },
    {
      "type": "shape",
      "background": "rgb(29,110,122)",
      "fillRule": "evenodd",
      "pixelPerfect": true,
      "rotation": -1.5708,
      "points": [
        36.08484,
        453.57459,
        43.40666,
        460.8406,
        22.6894,
        460.8406,
        15.20658,
        453.57459
      ]
    },
    {
      "type": "shape",
      "background": "rgb(29,110,122)",
      "fillRule": "evenodd",
      "pixelPerfect": true,
      "scaleX": -1,
      "rotation": -1.5708,
      "points": [
        36.08484,
        250.00835,
        43.40666,
        257.27437,
        22.6894,
        257.27437,
        15.20658,
        250.00835
      ]
    },
    {
      "type": "image",
      "name": {
        "cache": {
          "width": 100,
          "height": 100,
          "snapshotURL": "",
          "func": "__ht__function(g, rect, comp, data, view) {\nif (!data) return;\nvar content =  comp.getValue('content'),\n    autoScale = comp.getValue('autoScale'),\n    fontSize = comp.getValue('fontSize'),\n    fontFamily = comp.getValue('fontFamily'),\n    wordBreak = comp.getValue('wordBreak'),\n    vAlign = comp.getValue('vAlign'),\n    color = comp.getValue('color'),\n    lineHeight = comp.getValue('lineHeight'),\n    textAlign = comp.getValue('textAlign'),\n    padding = comp.getValue('padding'),\n    background = comp.getValue('background'),\n    fillContent = comp.getValue('fillContent');\n\nif (background) {// 画背景\n    g.save();\n    g.fillStyle = background;\n    g.beginPath();\n    g.rect(rect.x, rect.y, rect.width, rect.height);\n    g.fill();\n    g.restore();\n}\n\nif (!content) return;\n\ng.save();\ng.translate(rect.x, rect.y);\n// padding and font\nvar font = fontSize + 'px ' + fontFamily,\n    paddingTop, paddingRight, paddingBottom, paddingLeft, plist;\n\nif (padding.match(/[^0-9\\s\\.]/g)) {\n    paddingTop = paddingRight = paddingBottom = paddingLeft = 0;\n} else {\n    padding = padding.replace(/\\s\\s+/g, ' ');\n    padding = padding.replace(/^\\s+|\\s+$/g,'');\n    plist = padding.split(' ');\n    plist = plist.length > 0 ? plist : [0];\n\n    switch(plist.length) {\n        case 1:\n            paddingTop = paddingRight = paddingBottom = paddingLeft = parseFloat(plist[0]);\n            break;\n        case 2:\n            paddingTop = paddingBottom = parseFloat(plist[0]);\n            paddingRight = paddingLeft = parseFloat(plist[1]);\n            break;\n        case 3:\n            paddingTop = parseFloat(plist[0]);\n            paddingRight = paddingLeft = parseFloat(plist[1]);\n            paddingBottom = parseFloat(plist[2]);\n            break;\n        default:\n            paddingTop = parseFloat(plist[0]);\n            paddingRight = parseFloat(plist[1]);\n            paddingBottom = parseFloat(plist[2]);\n            paddingLeft = parseFloat(plist[3]);\n            break;\n    }\n}\n\nvar fx = paddingLeft, fy = paddingTop,\n    width = parseInt(rect.width) - paddingLeft - paddingRight,\n    height = parseInt(rect.height) - paddingTop - paddingBottom;\n\nvar getTextSize = function(font, text){\n    var g = document ? ht.Default.createCanvas().getContext(\"2d\") : null;\n    return function(font, text) {\n        g.font = font;\n        return g.measureText(text);\n    };\n}();\n\nvar replacePos = function (str, pos, text) {\n    var str = str.substring(0, pos-1) + text + str.substring(pos - 1,str.length);\n    return str;\n}\n\nvar breakText = function(text, width, font) {\n    var list = [],\n        preCut = 0,\n        i = 1;\n    for (len = text.length; i <= len; i++) {\n        var temp = text.substring(preCut, i),\n            size = getTextSize(font, temp);\n        if (size.width > width) {\n            if (i - 1 === preCut) {\n                list.push(text.substring(preCut, i));\n                preCut = i;\n            }\n            else {\n                list.push(text.substring(preCut, i - 1));\n                preCut = i - 1;\n            }\n        }\n    }\n\n    if (preCut !== i - 1) {\n        list.push(text.substring(preCut, i));\n    }\n    return list;\n};\n\nvar formatText = function(text, style) {\n    var list = [],\n        font = style.font,\n        height = style.height,\n        width = style.width,\n        wordBreak = style.wordBreak,\n        textList = text.split('\\n');\n\n    for (var j = 0, listLen = textList.length; j < listLen; j++) {\n        var subText = textList[j];\n        if (subText === '') {\n            subText = ' ';\n        }\n        if (wordBreak) {\n            Array.prototype.push.apply(list, breakText(subText, width, font));\n        } else {\n            var code = '',\n                array, codeArray, tempStr, size, subList, preSubstr = '';\n            for(var x = 0; x < subText.length; x++){\n                var char = subText.charAt(x);\n                if(char.match(/[a-z|A-Z]/g)) {\n                    code += '1';\n                }else {\n                    code += '2';\n                }\n            }\n\n            code = code.replace(/21/g,'2_1');\n            code = code.replace(/12/g,'1_2');\n\n            for(var i = 0; i < code.length; i++){\n                var char = code.charAt(i);\n                if(char.match(/\\_/g)) {\n                    subText = replacePos(subText, i + 1, '|');\n                }\n            }\n            array = subText.split('|'),\n            codeArray = code.split('_');\n\n            // 判断第一个是否\n            for (var i = 0, len = array.length; i < len; i++) {\n                tempStr = preSubstr + array[i];\n                size = getTextSize(font, tempStr);\n\n                if (codeArray[i][0] === '1') {// 英文单词\n\n                    if (size.width - 2 > width) {// 超出\n                        if (preSubstr) {// 有前串剩余\n                            list.push(preSubstr);\n                            preSubstr = '';\n                            i --;// 清空前串后继续执行一次当前循环\n                        } else {// 当前一行装不下一个单词的情况\n                            subList = breakText(array[i], width, font);\n                            Array.prototype.push.apply(list, subList.slice(0, subList.length - 1));\n                            preSubstr = subList[subList.length - 1];\n                        }\n                    } else if(size.width === width) {\n                        list.push(tempStr);\n                        preSubstr = '';\n                    } else {\n                        preSubstr = tempStr;\n                    }\n                } else {// 普通串\n                    if (size.width > width) {\n                        subList = breakText(tempStr, width, font);\n                        Array.prototype.push.apply(list, subList.slice(0, subList.length - 1));\n                        preSubstr = subList[subList.length - 1];\n                    } else {\n                        preSubstr = tempStr;\n                    }\n                }\n            }\n            if (preSubstr) {// 加入最后空余串\n                list.push(preSubstr);\n            }\n        }\n    }\n    return list;\n};\n\n\nvar tl = formatText(content, {\n    font: font,\n    width: width,\n    height: height,\n    wordBreak: wordBreak\n});\nif (autoScale && tl.length * lineHeight > height) {\n    // find cache\n    var cacheKey = '' + width + '-' +height + font + lineHeight;\n    var cacheMap = data.a('cacheScaleMap');\n    var i = 0,\n        lineOffset = 0,\n        maxTry = 4,\n        scale, rs,\n        tempList, rlh, preRS, scaledWidth, scaledHeight;\n    vAlign = 'top';\n    // use cache\n    if (cacheMap && cacheMap.key === cacheKey && cacheMap.content === content) {\n        scale = cacheMap.scale;\n        rs = 1 / scale;\n        rlh = scale * lineHeight;\n\n        scaledWidth = parseInt(width * rs);\n        scaledHeight = parseInt(height * rs);\n\n        g.scale(scale, scale);\n\n        tl = formatText(content, {\n            font: font,\n            width: scaledWidth,\n            height: height,\n            wordBreak: wordBreak\n        });\n    }\n    else {\n        cacheMap = {\n            key: cacheKey,\n            content: content\n        };\n\n        while (i < maxTry) {// try\n            scale = Math.sqrt(height / ((tl.length + lineOffset) * lineHeight));\n            rs = 1 / scale;\n            rlh = scale * lineHeight;\n\n            scaledWidth = parseInt(width * rs);\n            scaledHeight = parseInt(height * rs);\n\n            if (preRS) {\n                g.scale(preRS, preRS);\n            }\n\n            g.scale(scale, scale);\n\n            tempList = formatText(content, {\n                font: font,\n                width: scaledWidth,\n                height: height,\n                wordBreak: wordBreak\n            });\n            if (tempList.length * rlh > height) {\n                lineOffset += Math.ceil((tempList.length * rlh - height) / rlh + 0.5);\n                preRS = rs;\n            }\n            else if (tempList.length * rlh < height && Math.abs(height - tempList.length * rlh) > rlh * 2) {\n                lineOffset -= Math.floor((height - tempList.length * rlh) / rlh);\n                preRS = rs;\n            }\n            else {\n                tl = tempList;\n                break;\n            }\n            if (++i === maxTry) {\n                tl = tempList;\n            }\n        }\n        cacheMap.scale = scale;\n        data.a('cacheScaleMap', cacheMap);\n    }\n\n    fx = paddingLeft * rs;\n    fy = paddingTop * rs;\n\n    tl.forEach(function(t, i) {\n        ht.Default.drawText(g, t, font, color, fx, fy, scaledWidth, rlh, textAlign, vAlign);\n        fy += lineHeight;\n    });\n}\nelse if (fillContent && (tl.length + 1) * lineHeight < height) {\n    // find cache\n    var cacheKey = '' + width + '-' + height + font + lineHeight;\n    var cacheMap = data.a('cacheScaleMap');\n    var i = 0,\n        lineOffset = 0,\n        maxTry = 4,\n        scale, rs,\n        tempList, rlh, preRS, scaledWidth, scaledHeight;\n    vAlign = 'top';\n    // use cache\n    if (cacheMap && cacheMap.key === cacheKey && cacheMap.content === content) {\n        scale = cacheMap.scale;\n        rs = 1 / scale;\n        rlh = scale * lineHeight;\n\n        scaledWidth = parseInt(width * rs);\n        scaledHeight = parseInt(height * rs);\n\n        g.scale(scale, scale);\n\n        tl = formatText(content, {\n            font: font,\n            width: scaledWidth,\n            height: height,\n            wordBreak: wordBreak\n        });\n    }\n    else {\n        var currScale = Math.sqrt(height / (tl.length * lineHeight));\n        cacheMap = {\n            key: cacheKey,\n            content: content\n        };\n\n        while (i < maxTry) {// try\n            scale = currScale;\n            rs = 1 / scale;\n            rlh = scale * lineHeight;\n\n            scaledWidth = parseInt(width * rs);\n            scaledHeight = parseInt(height * rs);\n\n            if (preRS) {\n                g.scale(preRS, preRS);\n            }\n\n            g.scale(scale, scale);\n\n            tempList = formatText(content, {\n                font: font,\n                width: scaledWidth,\n                height: height,\n                wordBreak: wordBreak\n            });\n            if (tempList.length * rlh > height || (tempList.length * rlh < height && height - tempList.length * rlh > rlh * 0.8)) {\n                preRS = rs;\n                currScale *= Math.sqrt(height / (tempList.length * rlh));\n            }\n            else {\n                tl = tempList;\n                break;\n            }\n            if (++i === maxTry) {\n                tl = tempList;\n            }\n        }\n        cacheMap.scale = scale;\n        data.a('cacheScaleMap', cacheMap);\n    }\n\n    fx = paddingLeft * rs;\n    fy = paddingTop * rs;\n\n    tl.forEach(function(t, i) {\n        ht.Default.drawText(g, t, font, color, fx, fy, scaledWidth, rlh, textAlign, vAlign);\n        fy += lineHeight;\n    });\n}\nelse {\n    // set y by vAlign\n    if (vAlign === 'middle') {\n        fy += (height - tl.length * lineHeight) / 2;\n    } else if (vAlign === 'bottom') {\n        fy += (height - tl.length * lineHeight);\n    }\n\n    tl.forEach(function(t, i) {\n        ht.Default.drawText(g, t, font, color, fx, fy, width, lineHeight, textAlign, vAlign);\n        fy += lineHeight;\n    });\n}\ng.restore();\n}",
          "properties": {
            "content": {
              "valueType": "Multiline",
              "defaultValue": "HT 2D Editor",
              "name": "TBContent"
            },
            "autoScale": {
              "valueType": "Boolean",
              "defaultValue": true,
              "name": "TBAutoScale"
            },
            "wordBreak": {
              "valueType": "Boolean",
              "defaultValue": false,
              "name": "TBWordBreak"
            },
            "fontSize": {
              "valueType": "PositiveNumber",
              "defaultValue": 14,
              "name": "TBFontSize"
            },
            "fontFamily": {
              "valueType": "String",
              "defaultValue": "sans-serif, arial",
              "name": "TBFontFamily"
            },
            "textAlign": {
              "valueType": "Align",
              "defaultValue": "left",
              "name": "TBTextAlign"
            },
            "vAlign": {
              "valueType": "VAlign",
              "defaultValue": "middle",
              "name": "TBVerticalAlign"
            },
            "color": {
              "valueType": "Color",
              "defaultValue": "rgb(0,0,0)",
              "name": "TBColor"
            },
            "lineHeight": {
              "valueType": "PositiveNumber",
              "defaultValue": 18,
              "name": "TBLineHeight"
            },
            "background": {
              "valueType": "Color",
              "defaultValue": null,
              "name": "TBBackground"
            },
            "padding": {
              "valueType": "String",
              "defaultValue": "0",
              "name": "TBPadding",
              "description": "like CSS"
            },
            "fillContent": {
              "valueType": "Boolean",
              "defaultValue": true,
              "name": "占整个矩形"
            }
          }
        },
        "width": {
          "value": 100,
          "isSafeFunc": true,
          "func": "__ht__function(i){return i._width}"
        },
        "height": {
          "value": 100,
          "isSafeFunc": true,
          "func": "__ht__function(i){return i._height}"
        },
        "comps": [
          {
            "type": {
              "func": "__ht__function(i){return i.compType}",
              "isSafeFunc": true
            },
            "content": {
              "func": "style@content"
            },
            "autoScale": {
              "func": "style@autoScale"
            },
            "wordBreak": {
              "func": "style@wordBreak"
            },
            "fontSize": {
              "func": "style@fontSize"
            },
            "fontFamily": {
              "func": "style@fontFamily"
            },
            "textAlign": {
              "func": "style@textAlign"
            },
            "vAlign": {
              "func": "style@vAlign"
            },
            "color": {
              "func": "style@color"
            },
            "lineHeight": {
              "func": "style@lineHeight"
            },
            "background": {
              "func": "style@background"
            },
            "padding": {
              "func": "style@padding"
            },
            "fillContent": {
              "func": "style@fillContent"
            },
            "getValue": "__ht__function(V){var d=u(E,V);if(d===M&&g.properties){var f=g.properties[V];f&&(d=f.defaultValue)}return d}",
            "getColor": "__ht__function(P){return A(E.getValue(P))}"
          }
        ]
      },
      "pixelPerfect": true,
      "displayName": "地址",
      "rect": [
        88.16539,
        301.65098,
        150.83461,
        67.348
      ]
    },
    {
      "type": "image",
      "name": {
        "cache": {
          "width": 100,
          "height": 100,
          "snapshotURL": "",
          "func": "__ht__function(g, rect, comp, data, view) {\nif (!data) return;\nvar content =  comp.getValue('content'),\n    autoScale = comp.getValue('autoScale'),\n    fontSize = comp.getValue('fontSize'),\n    fontFamily = comp.getValue('fontFamily'),\n    wordBreak = comp.getValue('wordBreak'),\n    vAlign = comp.getValue('vAlign'),\n    color = comp.getValue('color'),\n    lineHeight = comp.getValue('lineHeight'),\n    textAlign = comp.getValue('textAlign'),\n    padding = comp.getValue('padding'),\n    background = comp.getValue('background'),\n    fillContent = comp.getValue('fillContent');\n\nif (background) {// 画背景\n    g.save();\n    g.fillStyle = background;\n    g.beginPath();\n    g.rect(rect.x, rect.y, rect.width, rect.height);\n    g.fill();\n    g.restore();\n}\n\nif (!content) return;\n\ng.save();\ng.translate(rect.x, rect.y);\n// padding and font\nvar font = fontSize + 'px ' + fontFamily,\n    paddingTop, paddingRight, paddingBottom, paddingLeft, plist;\n\nif (padding.match(/[^0-9\\s\\.]/g)) {\n    paddingTop = paddingRight = paddingBottom = paddingLeft = 0;\n} else {\n    padding = padding.replace(/\\s\\s+/g, ' ');\n    padding = padding.replace(/^\\s+|\\s+$/g,'');\n    plist = padding.split(' ');\n    plist = plist.length > 0 ? plist : [0];\n\n    switch(plist.length) {\n        case 1:\n            paddingTop = paddingRight = paddingBottom = paddingLeft = parseFloat(plist[0]);\n            break;\n        case 2:\n            paddingTop = paddingBottom = parseFloat(plist[0]);\n            paddingRight = paddingLeft = parseFloat(plist[1]);\n            break;\n        case 3:\n            paddingTop = parseFloat(plist[0]);\n            paddingRight = paddingLeft = parseFloat(plist[1]);\n            paddingBottom = parseFloat(plist[2]);\n            break;\n        default:\n            paddingTop = parseFloat(plist[0]);\n            paddingRight = parseFloat(plist[1]);\n            paddingBottom = parseFloat(plist[2]);\n            paddingLeft = parseFloat(plist[3]);\n            break;\n    }\n}\n\nvar fx = paddingLeft, fy = paddingTop,\n    width = parseInt(rect.width) - paddingLeft - paddingRight,\n    height = parseInt(rect.height) - paddingTop - paddingBottom;\n\nvar getTextSize = function(font, text){\n    var g = document ? ht.Default.createCanvas().getContext(\"2d\") : null;\n    return function(font, text) {\n        g.font = font;\n        return g.measureText(text);\n    };\n}();\n\nvar replacePos = function (str, pos, text) {\n    var str = str.substring(0, pos-1) + text + str.substring(pos - 1,str.length);\n    return str;\n}\n\nvar breakText = function(text, width, font) {\n    var list = [],\n        preCut = 0,\n        i = 1;\n    for (len = text.length; i <= len; i++) {\n        var temp = text.substring(preCut, i),\n            size = getTextSize(font, temp);\n        if (size.width > width) {\n            if (i - 1 === preCut) {\n                list.push(text.substring(preCut, i));\n                preCut = i;\n            }\n            else {\n                list.push(text.substring(preCut, i - 1));\n                preCut = i - 1;\n            }\n        }\n    }\n\n    if (preCut !== i - 1) {\n        list.push(text.substring(preCut, i));\n    }\n    return list;\n};\n\nvar formatText = function(text, style) {\n    var list = [],\n        font = style.font,\n        height = style.height,\n        width = style.width,\n        wordBreak = style.wordBreak,\n        textList = text.split('\\n');\n\n    for (var j = 0, listLen = textList.length; j < listLen; j++) {\n        var subText = textList[j];\n        if (subText === '') {\n            subText = ' ';\n        }\n        if (wordBreak) {\n            Array.prototype.push.apply(list, breakText(subText, width, font));\n        } else {\n            var code = '',\n                array, codeArray, tempStr, size, subList, preSubstr = '';\n            for(var x = 0; x < subText.length; x++){\n                var char = subText.charAt(x);\n                if(char.match(/[a-z|A-Z]/g)) {\n                    code += '1';\n                }else {\n                    code += '2';\n                }\n            }\n\n            code = code.replace(/21/g,'2_1');\n            code = code.replace(/12/g,'1_2');\n\n            for(var i = 0; i < code.length; i++){\n                var char = code.charAt(i);\n                if(char.match(/\\_/g)) {\n                    subText = replacePos(subText, i + 1, '|');\n                }\n            }\n            array = subText.split('|'),\n            codeArray = code.split('_');\n\n            // 判断第一个是否\n            for (var i = 0, len = array.length; i < len; i++) {\n                tempStr = preSubstr + array[i];\n                size = getTextSize(font, tempStr);\n\n                if (codeArray[i][0] === '1') {// 英文单词\n\n                    if (size.width - 2 > width) {// 超出\n                        if (preSubstr) {// 有前串剩余\n                            list.push(preSubstr);\n                            preSubstr = '';\n                            i --;// 清空前串后继续执行一次当前循环\n                        } else {// 当前一行装不下一个单词的情况\n                            subList = breakText(array[i], width, font);\n                            Array.prototype.push.apply(list, subList.slice(0, subList.length - 1));\n                            preSubstr = subList[subList.length - 1];\n                        }\n                    } else if(size.width === width) {\n                        list.push(tempStr);\n                        preSubstr = '';\n                    } else {\n                        preSubstr = tempStr;\n                    }\n                } else {// 普通串\n                    if (size.width > width) {\n                        subList = breakText(tempStr, width, font);\n                        Array.prototype.push.apply(list, subList.slice(0, subList.length - 1));\n                        preSubstr = subList[subList.length - 1];\n                    } else {\n                        preSubstr = tempStr;\n                    }\n                }\n            }\n            if (preSubstr) {// 加入最后空余串\n                list.push(preSubstr);\n            }\n        }\n    }\n    return list;\n};\n\n\nvar tl = formatText(content, {\n    font: font,\n    width: width,\n    height: height,\n    wordBreak: wordBreak\n});\nif (autoScale && tl.length * lineHeight > height) {\n    // find cache\n    var cacheKey = '' + width + '-' +height + font + lineHeight;\n    var cacheMap = data.a('cacheScaleMap');\n    var i = 0,\n        lineOffset = 0,\n        maxTry = 4,\n        scale, rs,\n        tempList, rlh, preRS, scaledWidth, scaledHeight;\n    vAlign = 'top';\n    // use cache\n    if (cacheMap && cacheMap.key === cacheKey && cacheMap.content === content) {\n        scale = cacheMap.scale;\n        rs = 1 / scale;\n        rlh = scale * lineHeight;\n\n        scaledWidth = parseInt(width * rs);\n        scaledHeight = parseInt(height * rs);\n\n        g.scale(scale, scale);\n\n        tl = formatText(content, {\n            font: font,\n            width: scaledWidth,\n            height: height,\n            wordBreak: wordBreak\n        });\n    }\n    else {\n        cacheMap = {\n            key: cacheKey,\n            content: content\n        };\n\n        while (i < maxTry) {// try\n            scale = Math.sqrt(height / ((tl.length + lineOffset) * lineHeight));\n            rs = 1 / scale;\n            rlh = scale * lineHeight;\n\n            scaledWidth = parseInt(width * rs);\n            scaledHeight = parseInt(height * rs);\n\n            if (preRS) {\n                g.scale(preRS, preRS);\n            }\n\n            g.scale(scale, scale);\n\n            tempList = formatText(content, {\n                font: font,\n                width: scaledWidth,\n                height: height,\n                wordBreak: wordBreak\n            });\n            if (tempList.length * rlh > height) {\n                lineOffset += Math.ceil((tempList.length * rlh - height) / rlh + 0.5);\n                preRS = rs;\n            }\n            else if (tempList.length * rlh < height && Math.abs(height - tempList.length * rlh) > rlh * 2) {\n                lineOffset -= Math.floor((height - tempList.length * rlh) / rlh);\n                preRS = rs;\n            }\n            else {\n                tl = tempList;\n                break;\n            }\n            if (++i === maxTry) {\n                tl = tempList;\n            }\n        }\n        cacheMap.scale = scale;\n        data.a('cacheScaleMap', cacheMap);\n    }\n\n    fx = paddingLeft * rs;\n    fy = paddingTop * rs;\n\n    tl.forEach(function(t, i) {\n        ht.Default.drawText(g, t, font, color, fx, fy, scaledWidth, rlh, textAlign, vAlign);\n        fy += lineHeight;\n    });\n}\nelse if (fillContent && (tl.length + 1) * lineHeight < height) {\n    // find cache\n    var cacheKey = '' + width + '-' + height + font + lineHeight;\n    var cacheMap = data.a('cacheScaleMap');\n    var i = 0,\n        lineOffset = 0,\n        maxTry = 4,\n        scale, rs,\n        tempList, rlh, preRS, scaledWidth, scaledHeight;\n    vAlign = 'top';\n    // use cache\n    if (cacheMap && cacheMap.key === cacheKey && cacheMap.content === content) {\n        scale = cacheMap.scale;\n        rs = 1 / scale;\n        rlh = scale * lineHeight;\n\n        scaledWidth = parseInt(width * rs);\n        scaledHeight = parseInt(height * rs);\n\n        g.scale(scale, scale);\n\n        tl = formatText(content, {\n            font: font,\n            width: scaledWidth,\n            height: height,\n            wordBreak: wordBreak\n        });\n    }\n    else {\n        var currScale = Math.sqrt(height / (tl.length * lineHeight));\n        cacheMap = {\n            key: cacheKey,\n            content: content\n        };\n\n        while (i < maxTry) {// try\n            scale = currScale;\n            rs = 1 / scale;\n            rlh = scale * lineHeight;\n\n            scaledWidth = parseInt(width * rs);\n            scaledHeight = parseInt(height * rs);\n\n            if (preRS) {\n                g.scale(preRS, preRS);\n            }\n\n            g.scale(scale, scale);\n\n            tempList = formatText(content, {\n                font: font,\n                width: scaledWidth,\n                height: height,\n                wordBreak: wordBreak\n            });\n            if (tempList.length * rlh > height || (tempList.length * rlh < height && height - tempList.length * rlh > rlh * 0.8)) {\n                preRS = rs;\n                currScale *= Math.sqrt(height / (tempList.length * rlh));\n            }\n            else {\n                tl = tempList;\n                break;\n            }\n            if (++i === maxTry) {\n                tl = tempList;\n            }\n        }\n        cacheMap.scale = scale;\n        data.a('cacheScaleMap', cacheMap);\n    }\n\n    fx = paddingLeft * rs;\n    fy = paddingTop * rs;\n\n    tl.forEach(function(t, i) {\n        ht.Default.drawText(g, t, font, color, fx, fy, scaledWidth, rlh, textAlign, vAlign);\n        fy += lineHeight;\n    });\n}\nelse {\n    // set y by vAlign\n    if (vAlign === 'middle') {\n        fy += (height - tl.length * lineHeight) / 2;\n    } else if (vAlign === 'bottom') {\n        fy += (height - tl.length * lineHeight);\n    }\n\n    tl.forEach(function(t, i) {\n        ht.Default.drawText(g, t, font, color, fx, fy, width, lineHeight, textAlign, vAlign);\n        fy += lineHeight;\n    });\n}\ng.restore();\n}",
          "properties": {
            "content": {
              "valueType": "Multiline",
              "defaultValue": "HT 2D Editor",
              "name": "TBContent"
            },
            "autoScale": {
              "valueType": "Boolean",
              "defaultValue": true,
              "name": "TBAutoScale"
            },
            "wordBreak": {
              "valueType": "Boolean",
              "defaultValue": false,
              "name": "TBWordBreak"
            },
            "fontSize": {
              "valueType": "PositiveNumber",
              "defaultValue": 14,
              "name": "TBFontSize"
            },
            "fontFamily": {
              "valueType": "String",
              "defaultValue": "sans-serif, arial",
              "name": "TBFontFamily"
            },
            "textAlign": {
              "valueType": "Align",
              "defaultValue": "left",
              "name": "TBTextAlign"
            },
            "vAlign": {
              "valueType": "VAlign",
              "defaultValue": "middle",
              "name": "TBVerticalAlign"
            },
            "color": {
              "valueType": "Color",
              "defaultValue": "rgb(0,0,0)",
              "name": "TBColor"
            },
            "lineHeight": {
              "valueType": "PositiveNumber",
              "defaultValue": 18,
              "name": "TBLineHeight"
            },
            "background": {
              "valueType": "Color",
              "defaultValue": null,
              "name": "TBBackground"
            },
            "padding": {
              "valueType": "String",
              "defaultValue": "0",
              "name": "TBPadding",
              "description": "like CSS"
            },
            "fillContent": {
              "valueType": "Boolean",
              "defaultValue": true,
              "name": "占整个矩形"
            }
          }
        },
        "width": {
          "value": 100,
          "isSafeFunc": true,
          "func": "__ht__function(i){return i._width}"
        },
        "height": {
          "value": 100,
          "isSafeFunc": true,
          "func": "__ht__function(i){return i._height}"
        },
        "comps": [
          {
            "type": {
              "func": "__ht__function(i){return i.compType}",
              "isSafeFunc": true
            },
            "content": {
              "func": "style@content"
            },
            "autoScale": {
              "func": "style@autoScale"
            },
            "wordBreak": {
              "func": "style@wordBreak"
            },
            "fontSize": {
              "func": "style@fontSize"
            },
            "fontFamily": {
              "func": "style@fontFamily"
            },
            "textAlign": {
              "func": "style@textAlign"
            },
            "vAlign": {
              "func": "style@vAlign"
            },
            "color": {
              "func": "style@color"
            },
            "lineHeight": {
              "func": "style@lineHeight"
            },
            "background": {
              "func": "style@background"
            },
            "padding": {
              "func": "style@padding"
            },
            "fillContent": {
              "func": "style@fillContent"
            },
            "getValue": "__ht__function(V){var d=u(E,V);if(d===M&&g.properties){var f=g.properties[V];f&&(d=f.defaultValue)}return d}",
            "getColor": "__ht__function(P){return A(E.getValue(P))}"
          }
        ]
      },
      "pixelPerfect": true,
      "displayName": "textBox",
      "rect": [
        11.61067,
        273.70738,
        17,
        164.012
      ]
    },
    {
      "type": "text",
      "text": "총 강변전소:",
      "color": "rgb(247,247,247)",
      "font": "16px Godo",
      "editable": false,
      "pixelPerfect": true,
      "rect": [
        31.16043,
        48.24294,
        74.98543,
        16.42145
      ]
    },
    {
      "type": "text",
      "text": {
        "func": "attr@totalDrop",
        "value": "1좌(110kV/10kV)"
      },
      "color": "#32D3EB",
      "font": "16px arial, sans-serif",
      "shadowColor": "#32D3EB",
      "movable": false,
      "editable": false,
      "pixelPerfect": true,
      "rect": [
        46.1054,
        69.985,
        151.47426,
        16.42145
      ]
    },
    {
      "type": "text",
      "text": "주 변환기:",
      "color": "rgb(247,247,247)",
      "font": "16px Godo",
      "movable": false,
      "editable": false,
      "pixelPerfect": true,
      "rect": [
        32.22401,
        116.3384,
        62.56803,
        16.42145
      ]
    },
    {
      "type": "text",
      "text": "고압 스위치 스테이션 :",
      "color": "rgb(247,247,247)",
      "font": "16px Godo",
      "movable": false,
      "editable": false,
      "pixelPerfect": true,
      "rect": [
        37.71126,
        486.42325,
        117.27401,
        27.69918
      ]
    },
    {
      "type": "shape",
      "background": "rgba(215,215,222,0.40)",
      "borderColor": "rgba(76,205,252,0.50)",
      "pixelPerfect": true,
      "rotation": 3.14159,
      "points": [
        56.48868,
        558.82748,
        56.48868,
        556.99513,
        197.57966,
        556.99513,
        197.57966,
        558.82748
      ]
    },
    {
      "type": "text",
      "text": "지",
      "align": "center",
      "color": "rgb(247,247,247)",
      "font": "18px arial, sans-serif",
      "pixelPerfect": true,
      "rect": [
        9.23765,
        294.04954,
        22.54774,
        15.20288
      ]
    },
    {
      "type": "text",
      "text": "역",
      "align": "center",
      "color": "rgb(247,247,247)",
      "font": "18px arial, sans-serif",
      "pixelPerfect": true,
      "rect": [
        9.23765,
        330.87155,
        22.54774,
        15.20288
      ]
    },
    {
      "type": "text",
      "text": "정",
      "align": "center",
      "color": "rgb(247,247,247)",
      "font": "18px arial, sans-serif",
      "pixelPerfect": true,
      "rect": [
        9.23765,
        367.69355,
        22.54774,
        15.20288
      ]
    },
    {
      "type": "text",
      "text": "보",
      "align": "center",
      "color": "rgb(247,247,247)",
      "font": "18px arial, sans-serif",
      "pixelPerfect": true,
      "rect": [
        9.23765,
        404.51556,
        22.54774,
        15.20288
      ]
    },
    {
      "type": "text",
      "text": "2대110±2×2.5%/10.5",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        46.1054,
        128.1765,
        140.7421,
        50
      ]
    },
    {
      "type": "text",
      "text": "kV 50/63MVA Dyn11",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        46.53746,
        146.50989,
        140.7421,
        50
      ]
    },
    {
      "type": "shape",
      "background": "rgba(20,20,61,0.40)",
      "borderColor": "rgb(41,155,217)",
      "movable": false,
      "editable": false,
      "rotation": 3.14159,
      "onUp": "__ht__function(event, data, view, point, width, height) {\nif(window.G){\n    G.event.fire({\n        kind: 'showCabinetInfo'\n    });\n}\n}",
      "points": [
        52.31148,
        240.10794,
        220.82932,
        240.10859,
        226.89348,
        248.16166,
        226.89343,
        296.13196,
        224.45694,
        302.44449,
        224.45694,
        385.12395,
        226.89331,
        392.39704,
        226.89324,
        437.82812,
        220.82895,
        447.6318,
        167.68584,
        447.63158,
        161.95689,
        437.82781,
        52.31111,
        437.82738,
        46.10567,
        428.02328,
        46.10572,
        392.39603,
        49.33067,
        385.12395,
        49.33067,
        302.44449,
        46.10583,
        296.13095,
        46.10589,
        248.16063,
        52.31148,
        240.10794
      ]
    },
    {
      "type": "text",
      "text": "전원 :",
      "color": "rgb(247,247,247)",
      "font": "16px Godo",
      "movable": false,
      "editable": false,
      "pixelPerfect": true,
      "rect": [
        53.28994,
        279.94707,
        74.98543,
        16.42145
      ]
    },
    {
      "type": "text",
      "text": {
        "func": "attr@power",
        "value": "중탄도변전소"
      },
      "color": "#32D3EB",
      "font": "16px arial, sans-serif",
      "shadowColor": "#32D3EB",
      "movable": false,
      "editable": false,
      "pixelPerfect": true,
      "rect": [
        68.23491,
        310.60165,
        151.47426,
        16.42145
      ]
    },
    {
      "type": "text",
      "text": "전력 공급 방식 :",
      "color": "rgb(247,247,247)",
      "font": "16px Godo",
      "movable": false,
      "editable": false,
      "pixelPerfect": true,
      "rect": [
        55.55299,
        355.42448,
        74.98543,
        16.42145
      ]
    },
    {
      "type": "text",
      "text": "단모선 분단 설정 2단",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        53.28994,
        362.117,
        140.7421,
        50
      ]
    },
    {
      "type": "text",
      "text": "10kV 모선",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        59.28994,
        379.89643,
        140.7421,
        50
      ]
    },
    {
      "type": "text",
      "text": "6#RCM",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        52.47148,
        499.27284,
        140.7421,
        50
      ]
    },
    {
      "type": "text",
      "text": "10KV 스테이션",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        52.97704,
        517.27284,
        140.7421,
        50
      ]
    },
    {
      "type": "shape",
      "background": "rgba(215,215,222,0.40)",
      "borderColor": "rgba(76,205,252,0.50)",
      "pixelPerfect": true,
      "rotation": 3.14159,
      "points": [
        56.48868,
        617.77439,
        56.48868,
        615.94204,
        197.57966,
        615.94204,
        197.57966,
        617.77439
      ]
    },
    {
      "type": "shape",
      "background": "rgba(215,215,222,0.40)",
      "borderColor": "rgba(76,205,252,0.50)",
      "pixelPerfect": true,
      "rotation": 3.14159,
      "points": [
        56.48868,
        674.99213,
        56.48868,
        673.15978,
        197.57966,
        673.15978,
        197.57966,
        674.99213
      ]
    },
    {
      "type": "text",
      "text": "5#DCL4#FCL",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        52.47148,
        558.27284,
        140.7421,
        50
      ]
    },
    {
      "type": "text",
      "text": "10KV 스테이션",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        52.97704,
        576.27284,
        140.7421,
        50
      ]
    },
    {
      "type": "text",
      "text": "공공보조",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        52.47148,
        615.27284,
        140.7421,
        50
      ]
    },
    {
      "type": "text",
      "text": "10KV 스테이션",
      "color": "#32D3EB",
      "font": "16px sans-serif, Arial",
      "rect": [
        52.97704,
        633.27284,
        140.7421,
        50
      ]
    }
  ]
}